---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r environment setup}

library(dplyr)
library(TCGAbiolinks)
library(DT)
library(purrr)
library(recount3)
library(DESeq2)
library(edgeR)
library(limma)
library(GSVA)
library(qusage)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(survival)
library(rpart)
library(pdacR)
library(Seurat)
library(ggplot2)
library(switchBox)
library(ncvreg)
library(stringr)
library(survival)
library(survminer)

```

```{r get all TCGA PAAD expression}

##Use recount3 to retrieve expression data for TCGA PAAD and normalize using different approaches

human_projects <- available_projects()

tcga_paad_info = subset(
    human_projects,
    project == "PAAD" & file_source == "tcga" & project_type == "data_sources"
)

proj_info <- map(seq(nrow(tcga_paad_info)), ~tcga_paad_info[.x, ])

## create the RangedSummarizedExperiment. the create_rse function works on one row a time 

rse_tcga_paad <- map(proj_info, ~create_rse(.x))

#### Creating TPM from counts and transcript length
count2tpm<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    gene_length <- rse@rowRanges$bp_length
    reads_per_rpk <- count_matrix/gene_length
    per_mil_scale <- colSums(reads_per_rpk)/1000000
    tpm_matrix <- t(t(reads_per_rpk)/per_mil_scale)
    return(tpm_matrix)
}

getCountMatrix<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    return(count_matrix)
}

## convert raw count matrix per cancer type to TPM and subset to only the genes of interest 
tpm_data<- map(rse_tcga_paad, count2tpm)
count_data <- map(rse_tcga_paad, getCountMatrix)

## get the metadata column 
metadata<- map(rse_tcga_paad, ~.x@colData@listData %>% as.data.frame())

# bind the data matrix across cancer types together 
tpm_data2<- purrr::reduce(tpm_data, cbind)
count_data2 <- purrr::reduce(count_data,cbind)

## bind the metadata across cancer types together
metadata2<- purrr::reduce(metadata, rbind)

##Ensure idential ID naming across datasets and save them
rownames(metadata2) <- metadata2$tcga.gdc_cases.samples.submitter_id
colnames(count_data2) <- rownames(metadata2)
colnames(tpm_data2) <- rownames(metadata2)

dim(tpm_data2)
dim(count_data2)
dim(metadata2)

tpm_data2[1:5,1:5]
count_data2[1:5,1:5]
metadata2[1:5,1:5]

saveRDS(tpm_data2,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_TPM_data.RDS")
saveRDS(count_data2,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_count_data.RDS")
saveRDS(metadata2,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_meta_data.RDS")

```

```{r load data}

#Load expression and metadata files
input_counts <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_count_data.RDS")
input_counts <- input_counts[,order(colnames(input_counts))]
input_tpm <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_TPM_data.RDS")
input_tpm <- input_tpm[,order(colnames(input_tpm))]
input_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_meta_data.RDS")
input_meta <- input_meta[order(rownames(input_meta)),]

##Load and add survival data to metadata
input_surv <- read.table("E:/Projects/Example_data/TCGA_PAAD/survival_PAAD_survival.txt",sep="\t",header=TRUE,row.names=1)
rownames(input_surv) <- paste0(rownames(input_surv),"A")
colnames(input_surv) <- paste0("Survival_",colnames(input_surv))
sum(rownames(input_surv) %in% rownames(input_meta))
sum(colnames(input_surv) %in% colnames(input_meta))
input_meta <- cbind(input_meta,input_surv[rownames(input_meta),])

##Replace . with _ for column names
names(input_meta) <- gsub("\\.", "_", names(input_meta))

##Reformat and factor primary sample type column used as covariate in modeling
input_meta$sample_type <- input_meta$tcga_cgc_sample_sample_type
input_meta$sample_type[input_meta$sample_type == "Primary Tumor"] <- "Tumor"
input_meta$sample_type[input_meta$sample_type == "Metastatic"] <- "Met"
input_meta$sample_type[input_meta$sample_type == "Solid Tissue Normal"] <- "Normal"
input_meta$sample_type <- factor(input_meta$sample_type,levels=c("Normal","Tumor","Met"))

### Check that sample names match in both files
all(colnames(input_counts) %in% rownames(input_meta))
all(colnames(input_counts) == rownames(input_meta))

##Filter non-expressed genes
keep <- rowSums(input_counts > 0) > 0
input_counts <- input_counts[keep,]
input_tpm <- input_tpm[keep,]

##Get HGNC symbols for remaining genes and replace ENSEMBL rownames
gene_ids <- rownames(input_counts)

# Remove version suffix if present
gene_ids_clean <- sub("\\..*", "", gene_ids)

# Connect to the Ensembl database
# You can specify an Ensembl release if needed, e.g., useEnsembl(biomart="ensembl", 
# version=109, dataset="hsapiens_gene_ensembl")
symbol_map <- mapIds(
    x         = org.Hs.eg.db,
    keys      = gene_ids_clean,
    column    = "SYMBOL",     # We want HGNC gene symbols
    keytype   = "ENSEMBL",    # Our keys are Ensembl gene IDs
    multiVals = "first"       # If multiple symbols map to one ID, take the first
)

##Replace ensembl IDs with symbols if not NA and not duplicated
temp_rownames <- ifelse(
    is.na(symbol_map[gene_ids_clean]),
    gene_ids_clean,
    symbol_map[gene_ids_clean]
)
rownames(input_counts) <- ifelse(
    duplicated(temp_rownames),
    gene_ids_clean,
    temp_rownames
)
rownames(input_tpm) <- rownames(input_counts)

##Derive CPM
lib_sizes <- colSums(input_counts)
input_cpm <- t(t(input_counts) / lib_sizes * 1e6)
saveRDS(input_cpm,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_CPM.RDS")

##Perform edgeR TMM normalization
dge <- DGEList(counts = input_counts, group = input_meta$sample_type)
dge <- calcNormFactors(dge, method = "TMM")
input_cpmtmm <- cpm(dge, normalized.lib.sizes = TRUE)
saveRDS(input_cpmtmm,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_TMM_normalized_cpm.RDS")

##Perform DESeq2 normalization
dds <- DESeqDataSetFromMatrix(countData = input_counts, colData = input_meta, design = ~ sample_type)

vsd <- vst(dds, blind = FALSE)
input_vst <- assay(vsd)

saveRDS(input_vst,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_DESeq2_normalized_vst.RDS")

##Save all expression formats and metadata
input_expression_set <- list(log2CPM=log2(input_cpm+1),log2TPM=log2(input_tpm+1),log2TMM=log2(input_cpmtmm+1),VST=input_vst)
saveRDS(input_expression_set,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_expression_set.RDS")
saveRDS(input_meta,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")


```

```{r derive scores}

##Load expression set
input_expression_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_expression_set.RDS")

##Load example GMTs relevant to TCGA PAAD
hp_gmt <- qusage::read.gmt("E:/Projects/Example_data/genesets/h.all.v2024.1.Hs.symbols.gmt")
pdac_genesets <- pdacR::gene_lists
pdac_genesets$Moffitt.Tumor <- NULL
pdac_genesets$Puleo.Centroids <- NULL
pdac_genesets$ICGC.SAM <- NULL
pdac_genesets$Moffitt.Top5s <- NULL
pdac_genesets$Moffitt.Top25s <- NULL
all_gmts <- c(hp_gmt,pdac_genesets)

##This geneset can be used to chromosomal locus estimates
#c1_gmt <- qusage::read.gmt("E:/Projects/Example_data/genesets/c1.all.v2024.1.Hs.symbols.gmt")

##Run GSVA on all included genesets to derive a score and save
input_gsva_set <- list(GSVA=list())#,ssGSEA=list())
for(temp_input_i in 1:length(input_expression_set)){
  temp_name <- names(input_expression_set)[[temp_input_i]]
  input_gsva_set$GSVA[[temp_name]] <- gsva(gsvaParam(input_expression_set[[temp_name]],all_gmts))
  #input_gsva_set$ssGSEA[[temp_name]] <- gsva(ssgseaParam(input_expression_set[[temp_name]],hp_gmt,normalize = FALSE))
}
saveRDS(input_gsva_set,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_gsva_set.RDS")




```

```{r run survival cut tree analysis}

##Load metadata and GSVA scores and add them to metadata
input_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")
input_gsva_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_gsva_set.RDS")
temp_gsva <- t(input_gsva_set$GSVA$log2CPM)[rownames(input_meta),]
colnames(temp_gsva) <- paste0("GSVA_",colnames(temp_gsva))
temp_meta <- cbind(input_meta,temp_gsva)

##Modified one entry with 0 for survival time that was causing an error
temp_meta$Survival_OS_time[temp_meta$Survival_OS_time == 0] <- 1

##Create survival formula for assessing all included GSVA scores in relation to overall survival
temp_formula <- as.formula(paste0("Surv(Survival_OS_time, Survival_OS) ~ ",paste(colnames(temp_meta)[grepl("GSVA_",colnames(temp_meta))],collapse = " + ")))

##Run and plot survival cutpoint analysis to identify the most prognostic covariates and cutpoints for the proposed survival model
fit <- rpart(temp_formula, data = temp_meta, method = "exp", control = rpart.control(cp=0.02,maxdepth=4,
                                                                                     minsplit = round(nrow(temp_meta)/5),
                                                                                     minbucket = round(nrow(temp_meta)/10)))

plot(fit,  uniform=TRUE,  main="Survival Tree")
text(fit, use.n=TRUE, all=TRUE, cex=.8)

```

```{r determine best signature celltype drivers with scRNAseq reference}

##Load PDAC scRNAseq reference atlas from Chijimatsu et al. paper
input_scData <- readRDS("E:/Projects/Cancer/PDAC Chijimatsu reconstruction/scDatasets/pk_all.rds")

##Load top gene sets from survival cutpoint analysis
my_gene_set1 <- all_gmts$Moffitt.F6_BasalLike.top100
my_gene_set2 <- all_gmts$CIBERSORT.Neutrophils
gene_set_list <- list("Moffitt_F6_BasalLike_top100" = my_gene_set1,"CIBERSORT_Neutrophils" = my_gene_set2)

##Evaluate the top prognostic gene sets for their enrichment in a specific cell type in the PDAC scRNAseq atlas
seurat_obj <- input_scData
for(temp_i in 1:length(gene_set_list)){

  # Add module score to Seurat object
  seurat_obj <- AddModuleScore(
    object   = seurat_obj,
    features = list(gene_set_list[[temp_i]]),
    name     = "CustomGeneset"
  )
  
  temp_plot <- DimPlot(seurat_obj, group.by = "Cell_type")
  print(temp_plot)

  temp_plot <- FeaturePlot(
    object   = seurat_obj, 
    features = "CustomGeneset1", 
    pt.size  = 0.5
  ) + ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)

  temp_plot <- VlnPlot(
    object   = seurat_obj, 
    features = "CustomGeneset1", 
    group.by = "Cell_type"  # or your cell type annotation column
  ) + ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)

  temp_plot <- DotPlot(
    seurat_obj, 
    features  = gene_set_list[[temp_i]], 
    group.by  = "Cell_type"
  ) + RotatedAxis() + 
    ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)

  temp_plot <- RidgePlot(seurat_obj, features = "CustomGeneset1", group.by = "Cell_type") + 
    ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)
  
}

##Extract and save marker genes for cell types that showed enrichment of the top prognostic GSVA scores
temp_scMarkers <- list()
temp_scMarkers[["Ductal_cell_type_2"]] <- 
  FindMarkers(
    object        = input_scData,
    ident.1       = "Ductal cell type 2",       # cell type or cluster name
    only.pos      = TRUE,            # only keep genes positively enriched in "T cells"
    logfc.threshold = 1.5,          # filter out genes with low logFC
    min.pct       = 0.1              # filter out genes not expressed in at least 10% of T cells
  )

temp_scMarkers[["Macrophage_cell"]] <- 
  FindMarkers(
      object        = input_scData,
      ident.1       = "Macrophage cell",       # cell type or cluster name
      only.pos      = TRUE,            # only keep genes positively enriched in "T cells"
      logfc.threshold = 1.25,          # filter out genes with low logFC
      min.pct       = 0.1              # filter out genes not expressed in at least 10% of T cells
  )

saveRDS(temp_scMarkers,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_exploratory_scMarkers.RDS")


```

```{r derive classifier for survival variables}

##Load metadata, GSVA scores, and expression data for TCGA PAAD
input_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")
input_gsva_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_gsva_set.RDS")
input_expression_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_expression_set.RDS")

##Add GSVA scores to metadata
temp_gsva <- t(input_gsva_set$GSVA$log2CPM)[rownames(input_meta),]
colnames(temp_gsva) <- paste0("GSVA_",colnames(temp_gsva))
temp_meta <- cbind(input_meta,temp_gsva)

##Define group based on top survival tree cutpoint results
temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High <- as.factor(temp_meta$GSVA_Moffitt.F6_BasalLike.top100 >= -0.3686)
temp_meta$CustomGroup_CIBERSORT_Neutrophils_High <- as.factor(temp_meta$GSVA_CIBERSORT.Neutrophils >= 0.03927)

##Use marker genes from scRNAseq as input to consider for top scoring pair classifier derivation
temp_scMarkers <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_exploratory_scMarkers.RDS")
input_expr <- input_expression_set$log2TPM

###Run classification for Ductal cell type 2
temp_expr <- input_expr[rownames(input_expr) %in% rownames(temp_scMarkers$Ductal_cell_type_2),]

##Define group for classification and run switchBox function to identify pairs of genes that can be used to identify it
temp_group <- temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High
temp_TSP_result <- SWAP.KTSP.Train(temp_expr,temp_group,krange = 50,FilterFunc = NULL)

##Format gene pairs into binary matrix of comparisons for each sample to use in logistic regression
temp_resultMat <- list()
for(temp_i in 1:nrow(temp_TSP_result$TSPs)){
  temp_name <- paste0(temp_TSP_result$TSPs[temp_i,1],"_",temp_TSP_result$TSPs[temp_i,2])
  temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[temp_TSP_result$TSPs[temp_i,1],] > temp_expr[temp_TSP_result$TSPs[temp_i,2],]))
}
temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))

##Perform logistic regression using top scoring pair result matrix and classification group to derive coefficients for each gene pair
test_ncv_result <- cv.ncvreg(temp_resultMat,
                             as.vector(as.integer(temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High)-1), alpha=0.5, nfolds = nrow(temp_resultMat))

temp_coefs <- coef(test_ncv_result)
temp_coefs <- temp_coefs[temp_coefs != 0]
temp_TSPs <- as.data.frame(list(geneA=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][1])),
                                geneB=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][2])),
                                coef=as.numeric(temp_coefs[-1])))

temp_TSP_classifier <- list(intercept=as.numeric(temp_coefs[1]),TSPs=temp_TSPs)

##Create function for classifier development

create_ncvTSP_classifier <- function(input_expression, input_group, input_scMarkers){
  temp_expr <- input_expression[rownames(input_expression) %in% input_scMarkers,]
  
  temp_TSP_result <- SWAP.KTSP.Train(temp_expr,as.factor(input_group),krange = 50,FilterFunc = NULL)

  ##Format gene pairs into binary matrix of comparisons for each sample to use in logistic regression
  temp_resultMat <- list()
  for(temp_i in 1:nrow(temp_TSP_result$TSPs)){
    temp_name <- paste0(temp_TSP_result$TSPs[temp_i,1],"_",temp_TSP_result$TSPs[temp_i,2])
    temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[temp_TSP_result$TSPs[temp_i,1],] > temp_expr[temp_TSP_result$TSPs[temp_i,2],]))
  }
  temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))
  
  ##Perform logistic regression using top scoring pair result matrix and classification group to derive coefficients for each gene pair
  test_ncv_result <- cv.ncvreg(temp_resultMat,
                               input_group, 
                               alpha=0.5, nfolds = nrow(temp_resultMat))
  
  temp_coefs <- coef(test_ncv_result)
  temp_coefs <- temp_coefs[temp_coefs != 0]
  temp_TSPs <- as.data.frame(list(geneA=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][1])),
                                  geneB=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][2])),
                                  coef=as.numeric(temp_coefs[-1])))
  
  ##Derive recommended probability cutoff
  all_TSPs <- c(temp_TSPs$geneA,temp_TSPs$geneB)
  sub_expr <- input_expression[rownames(input_expression) %in% all_TSPs,]
  
  temp_resultMat <- list()
  for(temp_i in 1:nrow(temp_TSPs)){
    temp_name <- paste0(temp_TSPs$geneA[temp_i],"_",temp_TSPs$geneB[temp_i])
    temp_resultMat[[temp_name]] <- as.vector(as.integer(sub_expr[temp_TSPs$geneA[temp_i],] > sub_expr[temp_TSPs$geneB[temp_i],]))
  }
  temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(sub_expr))
  
  ### p = exp(x*coef) / (1 + exp(x*coef))
  temp_resultVector <- rowSums(t(t(temp_resultMat) * temp_TSPs$coef))
  temp_resultProb <- exp(temp_resultVector) / (1 + exp(temp_resultVector))
  all_cutoff_values <- seq(1,99)/100
  min_errors <- length(input_group)
  for(temp_cutoff_i in 1:length(all_cutoff_values)){
    temp_cutoff_value <- all_cutoff_values[temp_cutoff_i]
    temp_table <- table(input_group,temp_resultProb > temp_cutoff_value)
    if(nrow(temp_table) == 2 & ncol(temp_table) == 2){
      temp_errors <- sum(temp_table[1,2] + temp_table[2,1])
      if(temp_errors < min_errors){
        min_errors <- temp_errors
        best_cutoffs <- c(temp_cutoff_value)
      }else if(temp_errors == min_errors){
        best_cutoffs <- c(best_cutoffs,temp_cutoff_value)
      }
    }
  }
  
  ##Return classifier
  temp_TSP_classifier <- list(intercept=as.numeric(temp_coefs[1]),TSPs=temp_TSPs,best_cutoff_probs=best_cutoffs)
  return(temp_TSP_classifier)
}

##Run with function
all_classifiers <- list()

##Run for PDAC tumor
test_expression <- input_expr
test_group <- as.vector(as.integer(temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High)-1)
test_scMarkers <- rownames(temp_scMarkers$Ductal_cell_type_2)
all_classifiers[["PDAC_tumor"]] <- create_ncvTSP_classifier(test_expression, test_group, test_scMarkers)

##Run for PDAC macrophages
test_expression <- input_expr
test_group <- as.vector(as.integer(temp_meta$CustomGroup_CIBERSORT_Neutrophils_High)-1)
test_scMarkers <- rownames(temp_scMarkers$Macrophage_cell)
all_classifiers[["PDAC_macrophage"]] <- create_ncvTSP_classifier(test_expression, test_group, test_scMarkers)

##Compare classifier to existing Purist classifier

##Create function for applying TSP classifier with pairs and coefficients
apply_TSP_classifier <- function(input_expression, input_classifier, use_with_missing=FALSE, best_cutoff_probability=NULL){
  
  if(is.null(best_cutoff_probability)){
    best_cutoff_probability <- input_classifier$best_cutoff_probs[1]
  }
  ##Check for missing classifier genes in input dataset with option to drop those pairs
  all_TSPs <- c(input_classifier$TSPs$geneA,input_classifier$TSPs$geneB)
  if(sum(all_TSPs %in% rownames(input_expression)) < length(all_TSPs)){
    missing_TSPs <- all_TSPs[!(all_TSPs %in% rownames(input_expression))]
    cat(paste0("The following genes were missing from the input dataset:\n",
                 paste(missing_TSPs,collapse=", ")))
    cat(paste0("Full input dataset:\n"))
    print(input_classifier$TSPs)
    
    if(use_with_missing==TRUE){
      classifier_rows_to_drop <- c()
      for(temp_i in 1:nrow(input_classifier$TSPs)){
        if(!(input_classifier$TSPs$geneA[temp_i] %in% rownames(input_expression)) | 
           !(input_classifier$TSPs$geneB[temp_i] %in% rownames(input_expression))){
          classifier_rows_to_drop <- c(classifier_rows_to_drop,temp_i)
        }
      }
      input_classifier <- input_classifier$TSPs[-classifier_rows_to_drop,]
    }else{
      return(paste0("Error: Failed due to missing classifier genes in the input data"))
    }
  }
  
  all_TSPs <- c(input_classifier$TSPs$geneA,input_classifier$TSPs$geneB)
  temp_expr <- input_expression[rownames(input_expression) %in% all_TSPs,]
  
  temp_resultMat <- list()
  for(temp_i in 1:nrow(input_classifier$TSPs)){
    temp_name <- paste0(input_classifier$TSPs[temp_i,1],"_",input_classifier$TSPs[temp_i,2])
    temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[input_classifier$TSPs[temp_i,1],] > temp_expr[input_classifier$TSPs[temp_i,2],]))
  }
  temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))
  
  ### p = exp(x*coef) / (1 + exp(x*coef))
  temp_resultVector <- rowSums(t(t(temp_resultMat) * input_classifier$TSPs$coef))
  temp_resultProb <- exp(temp_resultVector) / (1 + exp(temp_resultVector))
  temp_resultGroup <- as.factor(as.numeric(temp_resultProb > best_cutoff_probability))
  
  temp_classifier_result <- as.data.frame(list(prob=temp_resultProb,group=temp_resultGroup))
  rownames(temp_classifier_result) <- colnames(input_expression)
  return(temp_classifier_result)
}

#Load and format Purist classifier
load("E:/Projects/Cancer/fitteds_public_2019-02-12.Rdata")
temp_TSPs <- classifs$oct25_equivalent_freeze$TSPs
temp_coefs <- classifs$oct25_equivalent_freeze$fit$beta
temp_intercept <- temp_coefs[1]
temp_coefs <- temp_coefs[-1]
temp_TSPs <- temp_TSPs[temp_coefs != 0,]
temp_coefs <- temp_coefs[temp_coefs != 0]
temp_TSPs <- as.data.frame(list(geneA=temp_TSPs[,1], geneB=temp_TSPs[,2], coef=temp_coefs))
best_cutoffs <- c(0.5)

temp_TSP_classifier <- list(intercept=temp_intercept,TSPs=temp_TSPs,best_cutoff_probs=best_cutoffs)
all_classifiers[["Purist"]] <- temp_TSP_classifier

##Apply derived classifiers as well as published Purist classifier
all_classifier_results <- list()
for(temp_i in 1:length(all_classifiers)){
  temp_classifier_name <- names(all_classifiers)[temp_i]
  all_classifier_results[[temp_classifier_name]] <- apply_TSP_classifier(input_expr,all_classifiers[[temp_classifier_name]])
}

##Compare results to Purist in TCGA PAAD
temp_meta$test_surv_group1 <- as.factor(all_classifier_results$PDAC_tumor$group)
temp_meta$test_surv_group2 <- as.factor(all_classifier_results$Purist$group)

# Create the Surv object
surv_object <- Surv(time = temp_meta$Survival_OS_time, event = temp_meta$Survival_OS)

# Kaplan-Meier fit by 'group'
fit1 <- survfit(surv_object ~ test_surv_group1, data = temp_meta)
fit2 <- survfit(surv_object ~ test_surv_group2, data = temp_meta)

# Use ggsurvplot for a survival curve of both classifier groups
temp_plot1 <- ggsurvplot(fit1, 
              data = temp_meta,
              pval = TRUE,            # adds p-value for log-rank test
              conf.int = TRUE,        # adds confidence intervals
              risk.table = TRUE,      # add risk table at the bottom
              xlab = "Time",
              ylab = "Survival Probability",
              legend.title = "Group",
              legend.labs = levels(temp_meta$test_surv_group1),
              title = "Overall survival with scClassifier groups")

temp_plot2 <- ggsurvplot(fit2, 
              data = temp_meta,
              pval = TRUE,            # adds p-value for log-rank test
              conf.int = TRUE,        # adds confidence intervals
              risk.table = TRUE,      # add risk table at the bottom
              xlab = "Time",
              ylab = "Survival Probability",
              legend.title = "Group",
              legend.labs = levels(temp_meta$test_surv_group2),
              title = "Overall survival with Purist groups")

print(temp_plot1)
print(temp_plot2)


```

```{r next steps for planning}

###Create iterative loop for combined survival cutpoint and cell type enrichment analysis to loop until score with prognostic value and cell type enrichment are found
#For this, assess survival cutpoint 1 for cell type enrichment past a certain fold in a relevant atlas for the indication in question
#If cell type enrichment fails, rerun survival cutpoint analysis with variation in cp, minsplit, and minbucket variables
#For cell type enrichment, determine a certain fold enrichment over other cell types that is acceptable
#Option to also assess 2nd level of cuts for additional cell type specificity as with macrophages in PDAC

###Testing this iterative process below

find_cellEnrichedPrognostic_scores <- function(input_meta,
                                               input_gsva,
                                               input_outcome_time,
                                               input_outcome_result,
                                               input_sc_dataset,
                                               input_gmts){
  temp_gsva <- t(input_gsva)[rownames(input_meta),]
  colnames(temp_gsva) <- paste0("GSVA_",colnames(temp_gsva))
  temp_meta <- cbind(input_meta,temp_gsva)
  
  ##Create survival formula for assessing all included GSVA scores in relation to overall survival
  temp_formula <- as.formula(paste0("Surv(",input_outcome_time,", ",input_outcome_result,") ~ ",
                                    paste(colnames(temp_meta)[grepl("GSVA_",colnames(temp_meta))],collapse = " + ")))
  
  temp_cp <- 0.05
  temp_minsplit <- round(nrow(temp_meta)/5)
  temp_minbucket <- round(nrow(temp_meta)/10)
  
  flag_primary_cutpoint_sc_enrichment <- FALSE
  final_iterations <- 0
  temp_progFeature <- NULL
  temp_progCutoff <- NULL
  cat(paste0("Running survival cutpoint analysis to identify the best prognostic feature and cutpoint with cell type association.\n"))
  while(flag_primary_cutpoint_sc_enrichment == FALSE & final_iterations < 10){
    temp_fit <- rpart(temp_formula, data = temp_meta, method = "exp", 
                      control = rpart.control(cp=temp_cp,
                                              maxdepth=1,
                                              minsplit = temp_minsplit,
                                              minbucket = temp_minbucket))
    temp_progFeature <- names(temp_fit$variable.importance)[1]
    temp_progCutoff <- temp_fit$splits[temp_progFeature,"index"]
    
    input_geneset_name <- str_replace(temp_progFeature,"GSVA_","")
    
    # Add module score to Seurat object
    seurat_obj <- AddModuleScore(
      object   = input_sc_dataset,
      features = list(input_gmts[[input_geneset_name]]),
      name     = "CustomGeneset"
    )
    temp_result <- as.data.frame(seurat_obj@meta.data %>% 
                                 group_by(Cell_type) %>% 
                                 summarize(mean_ModuleScore = mean(CustomGeneset1)))
    temp_min <- min(temp_result$mean_ModuleScore)
    temp_result$norm_Module_score <- temp_result$mean_ModuleScore - temp_min
    temp_max_i <- which.max(temp_result$norm_Module_score)
    temp_max_value <- temp_result$norm_Module_score[temp_max_i]
    temp_max_cell_type <- temp_result$Cell_type[temp_max_i]
    comp_result <- temp_result$norm_Module_score[temp_result$Cell_type != temp_max_cell_type]
    
    if(sum(temp_max_value >= comp_result*2) == length(comp_result)){
      flag_primary_cutpoint_sc_enrichment <- TRUE
      plot(temp_fit,  uniform=TRUE,  main="Survival Tree")
      text(temp_fit, use.n=TRUE, all=TRUE, cex=.8)
      temp_best_surv_plot <- recordPlot()
    }else{
      if(temp_cp > 0.01){
        temp_cp <- temp_cp - 0.01
      }else{
        if(final_iterations <= 9){
          temp_minsplit <- temp_minsplit * 0.8
          temp_minbucket <- temp_minbucket * 0.8
        }
        final_iterations <- final_iterations + 1
      }
    }
  }
  
  if(flag_primary_cutpoint_sc_enrichment == TRUE){
    
    cat(paste0("Running single cell marker derivation to obtain a marker list between 500 and 1000 genes in size.\n"))
    
    temp_thresholdFC <- 1.5
    temp_scMarker_size <- 0
    temp_scMarkers <- NULL
    enrichment_iterations <- 0
    while((temp_scMarker_size < 500 | temp_scMarker_size > 1000) & enrichment_iterations < 10){
      temp_scMarkers <- FindMarkers(
        object        = input_sc_dataset,
        ident.1       = temp_max_cell_type,       # cell type or cluster name
        only.pos      = TRUE,            # only keep genes positively enriched in "T cells"
        logfc.threshold = temp_thresholdFC,          # filter out genes with low logFC
        min.pct       = 0.1              # filter out genes not expressed in at least 10% of T cells
        )
      temp_scMarker_size <- nrow(temp_scMarkers)
      if(temp_scMarker_size > 1000){
        temp_thresholdFC <- temp_thresholdFC * 1.1
        enrichment_iterations <- enrichment_iterations + 1
      }else if(temp_scMarker_size < 500){
        temp_thresholdFC <- temp_thresholdFC * 0.5
        enrichment_iterations <- enrichment_iterations + 1
      }
    }
    if(enrichment_iterations == 10){
      cat(paste0("Failed to identify sufficient numbers of enriched markers for the cell type associating with the identified prognostic feature.\n",
                 "The best obtained marker list will be returned despite being outside the optimal range of approximately 500-1000 genes.\n"))
    }
    final_prog_info <- list(final_progFeature=temp_progFeature,
                            final_progCutoff=temp_progCutoff,
                            final_survPlot=temp_best_surv_plot,
                            final_cp=temp_cp,
                            final_minsplit=temp_minsplit,
                            final_minbucket=temp_minbucket,
                            final_enriched_cellType=temp_max_cell_type,
                            final_scMarkers=temp_scMarkers,
                            final_scMarker_enrichment_threshold=temp_thresholdFC)
    return(final_prog_info)
  }else{
    temp_message <- paste0("Failed to identify meaningful prognostic groups for a score showing cell type enrichment.\n")
    return(temp_message)
  }
}

##Load metadata and GSVA scores and add them to metadata
test_sc_dataset <- readRDS("E:/Projects/Cancer/PDAC Chijimatsu reconstruction/scDatasets/pk_all.rds")

test_outcome_time <- "Survival_OS_time"
test_outcome_result <- "Survival_OS"

test_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")
##Modified one entry with 0 for survival time that was causing an error
test_meta$Survival_OS_time[test_meta$Survival_OS_time == 0] <- 1

test_gsva <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_gsva_set.RDS")
test_gsva <- test_gsva$GSVA$log2CPM

##Load example GMTs relevant to TCGA PAAD
hp_gmt <- qusage::read.gmt("E:/Projects/Example_data/genesets/h.all.v2024.1.Hs.symbols.gmt")
pdac_genesets <- pdacR::gene_lists
pdac_genesets$Moffitt.Tumor <- NULL
pdac_genesets$Puleo.Centroids <- NULL
pdac_genesets$ICGC.SAM <- NULL
pdac_genesets$Moffitt.Top5s <- NULL
pdac_genesets$Moffitt.Top25s <- NULL
all_gmts <- c(hp_gmt,pdac_genesets)
test_gmts <- all_gmts

test_result <- find_cellEnrichedPrognostic_scores(test_meta,test_gsva,test_outcome_time,test_outcome_result,test_sc_dataset,test_gmts)


```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
